#include "wc.h"
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>


int main(int argc, char **argv)
{
		long fsize, fsize_each, start_pos, bytes_to_count;
		FILE *fp;
		count_t count, total_count;
		int pd[10][2], exit_status;
		struct timespec begin, end;
		int nChildProc = 0;
		pid_t child_process[10];
		
		/* 1st arg: filename */
		if(argc < 2) {
				printf("usage: wc <filname> [# processes] [crash rate]\n");
				return 0;
		}
		
		/* 2nd (optional) arg: number of child processes */
		if (argc > 2) {
				nChildProc = atoi(argv[2]);
				if(nChildProc < 1) nChildProc = 1;
				if(nChildProc > 10) nChildProc = 10;
		}

		/* 3rd (optional) arg: crash rate between 0% and 100%. Each child process has that much chance to crash*/
		if(argc > 3) {
				crashRate = atoi(argv[3]);
				if(crashRate < 0) crashRate = 0;
				if(crashRate > 50) crashRate = 50;
		}
		
		printf("# of Child Processes: %d\n", nChildProc);
		printf("crashRate RATE: %d\n", crashRate);

		count.linecount = 0;
		count.wordcount = 0;
		count.charcount = 0;
		total_count.linecount = 0;
		total_count.wordcount = 0;
		total_count.charcount = 0;

  		// start to measure time
		clock_gettime(CLOCK_REALTIME, &begin);

		// Open file in read-only mode
		fp = fopen(argv[1], "r");

		if(fp == NULL) {
				printf("File open error: %s\n", argv[1]);
				printf("usage: wc <filname>\n");
				return 0;
		}

		// get a file size
		fseek(fp, 0L, SEEK_END);
		fsize = ftell(fp);
		fclose(fp);
		
		/* word_count() has 3 arguments.
			* 1st: file descriptor
			* 2nd: starting offset
			* 3rd: number of bytes to count from the offset
			*/
		
		// if childprocess not given.
		if (argc == 2){
			fp = fopen(argv[1], "r");
			total_count = word_count(fp, 0, fsize);
			fclose(fp);
		}
		// make multiple child threads here. And calculate the start and end bytes to count for each thread. 
		else{
			fsize_each = fsize/nChildProc;
			int i;
			for (i=0; i<nChildProc; i++){
				start_pos = fsize_each*i;
				if (i == nChildProc-1)
					bytes_to_count = fsize - start_pos;
				else
					bytes_to_count = fsize_each;

				if (pipe(pd[i]) == -1){
					printf("Unable to create pipe.\n");
					return 1;
				}
	
				child_process[i] = fork();
				// child process: call the count function and return the count.
				if (child_process[i] == 0){
					fp = fopen(argv[1], "r");
					close(pd[i][0]);
					count = word_count(fp, start_pos, bytes_to_count);
					printf("for process %d,\tcharcount=%d\twordcount=%d\tlinecount=%d\n", getpid(), count.charcount, count.wordcount, count.linecount);
					write(pd[i][1], &count, sizeof(count));
					fclose(fp);
					exit(0);
				}
			}

			for (i=0; i<nChildProc; i++){
				int failure;
				do{
					// parent process: wait for process, if child process doesn't crash, calculate total count.
					pid_t cpid = waitpid(child_process[i], &exit_status, 0);
					// if child process exited normally, calculate the total count.
					if (WIFEXITED(exit_status)) {
						close(pd[i][1]);
						read(pd[i][0], &count, sizeof(count));
						total_count.charcount += count.charcount;
						total_count.wordcount += count.wordcount;
						total_count.linecount += count.linecount;
						failure = 0;
					}
					// if process exited abnormally, recreate a child process to calculate the count
					if (WIFSIGNALED(exit_status)) {
						printf("Child process with pid %d exited abnormally via signal %d\n", cpid, WTERMSIG(exit_status));
						failure = 1;
						start_pos = fsize_each*i;
						if (i == nChildProc-1)
							bytes_to_count = fsize - start_pos;
						else
							bytes_to_count = fsize_each;
						
						// create child process with the same logic as above.
						child_process[i] = fork();
						// child process: call the count function and return the count.
						if (child_process[i] == 0){
							fp = fopen(argv[1], "r");
							close(pd[i][0]);
							count = word_count(fp, start_pos, bytes_to_count);
							printf("for process %d,\tcharcount=%d\twordcount=%d\tlinecount=%d\n", getpid(), count.charcount, count.wordcount, count.linecount);
							write(pd[i][1], &count, sizeof(count));
							fclose(fp);
							exit(0);
						}
					}
				}while(failure);
			}
		}

		clock_gettime(CLOCK_REALTIME, &end);
		long seconds = end.tv_sec - begin.tv_sec;
		long nanoseconds = end.tv_nsec - begin.tv_nsec;
		double elapsed = seconds + nanoseconds*1e-9;

		printf("\n========= %s =========\n", argv[1]);
		printf("Total Lines : %d \n", total_count.linecount);
		printf("Total Words : %d \n", total_count.wordcount);
		printf("Total Characters : %d \n", total_count.charcount);
		printf("======== Took %.3f seconds ========\n", elapsed);

		return(0);
}
